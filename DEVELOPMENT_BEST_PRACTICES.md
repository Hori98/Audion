# 開発ベストプラクティス：共通化優先・保守性重視開発方針

## 🎯 基本原則

### 1. **共通化ファースト原則**
- 新機能実装前に**必ず既存類似機能を検索・分析**
- 同じ動作が確認できる場合は**共通化を最優先**
- 重複実装は技術負債として即座に対処

### 2. **保守性最優先原則**
- コードの可読性 > パフォーマンス（明確な必要性がない限り）
- 一貫性のあるパターン・命名規則の維持
- 将来の変更を想定した柔軟な設計

## 🔍 自動確認フロー

### ステップ1: 類似機能検索
新機能要求時に以下を**必ず実行**：

```bash
# 1. 関連キーワードでコードベース検索
grep -r "キーワード" . --include="*.tsx" --include="*.py"

# 2. 類似エンドポイント/コンポーネント特定
find . -name "*Similar*" -o -name "*Related*"

# 3. 同一ドメインロジック検索
grep -r "同一概念" . --include="*.py" --include="*.tsx"
```

### ステップ2: 共通化可能性判定
以下の**判定基準**で評価：

#### ✅ 共通化すべき条件
- [ ] **入力データ形式が同一または類似**
- [ ] **出力結果の構造が同一**
- [ ] **ビジネスロジックが本質的に同じ**
- [ ] **エラーハンドリングパターンが同一**
- [ ] **設定パラメータで差分を吸収可能**

#### ❌ 共通化しない条件
- [ ] **パフォーマンス要件が大幅に異なる**
- [ ] **セキュリティ要件が異なる**
- [ ] **ライフサイクルが大幅に異なる**
- [ ] **責任範囲が明確に分離されている**

### ステップ3: 実装方針決定
```
IF 共通化可能 THEN
    既存機能をベースに拡張・パラメータ化
ELSE IF 部分共通化可能 THEN
    共通部分を抽出してユーティリティ化
ELSE
    新規実装（ただし一貫性あるパターンで）
```

## 📋 実装チェックリスト

### 🔧 共通化実装時
- [ ] **既存機能への影響を確認**（破壊的変更の回避）
- [ ] **パラメータ・設定による差分吸収**
- [ ] **明確な命名規則の適用**
- [ ] **エラーハンドリングの統一**
- [ ] **ログ出力形式の統一**
- [ ] **テスト要件の整理**

### 🆕 新規実装時
- [ ] **既存パターンとの一貫性確保**
- [ ] **将来の共通化を想定した設計**
- [ ] **設定外部化の考慮**
- [ ] **拡張ポイントの明確化**

## 🎯 具体的適用パターン

### バックエンドAPI
```python
# ❌ 悪い例：重複したエンドポイント
@app.post("/api/audio/create")
async def create_audio():
    # 個別実装

@app.post("/api/audio/instant-multi") 
async def create_instant():
    # 似たような処理を別実装

# ✅ 良い例：共通化されたエンドポイント
@app.post("/api/audio/create")
async def create_audio(request: AudioRequest, mode: str = "standard"):
    return await audio_service.create(request, mode)
```

### フロントエンドコンポーネント
```tsx
// ❌ 悪い例：類似コンポーネントの重複
function PlayButton() { /* 個別実装 */ }
function StreamingPlayButton() { /* 似た実装 */ }

// ✅ 良い例：パラメータ化された共通コンポーネント
function PlayButton({ mode = "standard", streaming = false }) {
  const handler = streaming ? handleStreamingPlay : handleStandardPlay;
  return <button onClick={handler}>Play</button>;
}
```

## 🚨 警告サイン

### すぐに共通化検討すべき状況
1. **同じような名前の関数/コンポーネントが複数存在**
2. **似たようなロジックをコピペした場合**
3. **「〜のやつと似てるけど少し違う」という実装**
4. **同じバグが複数箇所で発生**
5. **同じ修正を複数箇所で行う必要**

## 🔄 継続的改善プロセス

### 週次レビュー
- [ ] **新規追加コードの共通化機会確認**
- [ ] **重複コードパターンの検出**
- [ ] **リファクタリング候補の特定**

### 月次レビュー
- [ ] **アーキテクチャ一貫性の確認**
- [ ] **技術負債の評価・優先順位付け**
- [ ] **ベストプラクティス更新**

## 📝 実装時の自動確認事項

新機能実装時に**必ず確認**：

1. **「この機能、既存のものと似てない？」**
2. **「既存コードで拡張・設定変更で実現できない？」**
3. **「同じパターンで実装した他の機能はある？」**
4. **「将来似たような機能が追加される可能性は？」**
5. **「この実装方法は他の箇所と一貫している？」**

## 🎖️ 成功指標

### 技術的指標
- **コード重複率の削減**
- **類似機能の統合数**
- **共通コンポーネント利用率**
- **バグ修正の影響範囲縮小**

### 開発効率指標  
- **新機能開発時間の短縮**
- **同一バグ修正の作業時間削減**
- **コードレビュー時間の短縮**

---

## 📚 参考：よくある共通化パターン

### 1. バリデーション処理
```python
# 共通バリデーター関数
def validate_audio_request(request, mode="standard"):
    # 共通バリデーション + モード別特殊要件
```

### 2. データ変換処理
```python
# 共通変換器
def transform_article_data(articles, format="standard"):
    # 基本変換 + フォーマット別調整
```

### 3. UI状態管理
```tsx
// 共通Hook
function useAudioPlayer(mode = "standard") {
  // 共通ロジック + モード別動作
}
```

### 4. エラーハンドリング
```python
# 共通エラーハンドラー
def handle_audio_error(error, context="general"):
    # 統一されたエラー処理 + コンテキスト別対応
```

---

**💡 重要**: このベストプラクティスは生きたドキュメントです。新しいパターンや改善点を発見したら随時更新してください。